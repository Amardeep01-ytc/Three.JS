Materials :
    - Materials are used to put a color o each visible pixel of the geometries 
    - The algorithm are written in programs called shaders
    - We don't need to write shaders and we can use built-in materials

Prepare our scence :
    - Create 3 Meshes composed of 3 different geometries (sphere, plane and torus)
    - We use the same MeshBasicMatrial on all 3
    - Rotate the objects in the tick function
        sphere.rotation.y = 0.1 * elapsedTime
        plane.rotation.y = 0.1 * elapsedTime
        torus.rotation.y = 0.1 * elapsedTime

        sphere.rotation.x = 0.1 * elapsedTime
        plane.rotation.x = 0.1 * elapsedTime
        torus.rotation.x = 0.1 * elapsedTime
    - we need some textures 
      Load all the door texture with a TextureLoader
        const textureLoader = new THREE.TextureLoader()

        const doorColorTexture = textureLoader.load('/textures/door/color.jpg')
        const doorAlphaTexture = textureLoader.load('/textures/door/alpha.jpg')
        const doorAmbientOcclusionTexture = textureLoader.load('/textures/door/ambientOcclusion.jpg')
        const doorHeightTexture = textureLoader.load('/textures/door/height.jpg')
        const doorNormalTexture = textureLoader.load('/textures/door/normal.jpg')
        const doorMetalnessTexture = textureLoader.load('/textures/door/metalness.jpg')
        const doorRoughnessTexture = textureLoader.load('/textures/door/roughness.jpg')
        const matcapTexture = textureLoader.load('/textures/matcaps/1.png')
        const gradientTexture = textureLoader.load('/textures/gradients/3.jpg')
    - Until now we used the MeshBasicMaterial which applies a uniform color or a texture on our geometry 
    - Search for 'material' on the Three.js documentation
      We are going to test them all

1.MeshBasicMaterial :
        - MeshBasicMterial is the most basic material but we didn't cover all its properties 
        - Most of materials properties can be set in two ways
            1st Way -->
            const material = new THREE.MeshBasicMaterial({
            map : doorColorTexture
            })
            
            2nd way -->
            const material = new THREE.MeshBasicMaterial()
            material.map = doorColorTexture
        We wil use senond method
        - Map will apply a texture on the surface of the geometry 
    
COLOR :     
    - Color will apply a uniform color on the surface of the geometry 
       Once instantiated, the color property becomes a color
       material.color = new THREE.Color('#ff0000')
       material.color = new THREE.Color('#f00')
       material.color = new THREE.Color('red')
       material.color = new THREE.Color('rgb(255, 0, 0')
       material.color = new THREE.Color(0xff0000)

    - WE can combine color and map(texture)
        material.map = doorColorTexture
        material.color = new THREE.Color('#ff0000')    
    
    - Wireframe will show the triangles that compose the geometry
        material.Wireframe = true
    
    - Opacity controls the general opacity 
       We need to set transparent = true
        material.transparent = true
        material.opacity = 0.5

    - alphaMap controls the transparency with a texture
        material.transparent = true
        material.alphaMap = doorAlphaTexture
    
    - side lets you decide which side of a face is visible
        * THREE.FrontSide(default)
        * THREE.BackSide
        * THREE.DoubleSide
        material.side = THREE.DoubleSide

2. Mesh Normal Material :
    - The MeshNormalMaterial displays a nice purple color that looks like the normal texture we saw in the texture lesson
        const material = new THREE.MeshNormalMaterial()
    - Normals are information that contains the direction of the outside of the face
    - Normals can be use for lighting, reflection, refraction etc
    - MeshNormalMaterial shares common properties with MeshBasicMaterial like wireframe, transparent, opacity and side but there is also a flatShading property
        material.flatShading = true
      flatShading will flattern the faces, meaning that the normals won't be interpolated between the vertices
    - MeshNormalMaterial is usually used to debug normals, but the color looks so great that you can use it for your projects 

3.MeshMatcapMaterial :
    - MeshMatcapMaterial will disply a color by using  the normals as a reference to pick the right color on a texture that looks like a sphere
    - Set the matcap texture with the matcap property
        const material = new THREE.MeshMatcapMaterial()
        material.matcap = matcapTexture
       We get an illusion that the objects are being illuminated
    - Try different textures available on the /static/textures/matcaps/ folder
        const matcapTextures = textureLoader.load('/textures/matcaps/2.png')
        const matcapTextures = textureLoader.load('/textures/matcaps/3.png')
        const matcapTextures = textureLoader.load('/textures/matcaps/4.png')
        const matcapTextures = textureLoader.load('/textures/matcaps/5.png')
        const matcapTextures = textureLoader.load('/textures/matcaps/6.png')
        const matcapTextures = textureLoader.load('/textures/matcaps/7.png')
        const matcapTextures = textureLoader.load('/textures/matcaps/8.png')
    - To find matcap textures: https://github.com/nidorx/matcaps
       You can also create your own with 3D software
       or you can create it in 2D software like photoshop

4. MeshDepthMaterial :
    - MeshDepthMaterial will simply color the geometry in white if it's close to the near and in black if it's to the far value of the camera
        const material = new THREE.MeshDepthMaterial()

Adding some light :
    - create an AmbientLight
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5)
        scene.add(ambientLight)
    - create a point light
        const pointLight = new THREE.PointLight(0xffffff, 0.5)
        pointLight.position.x = 2
        pointLight.position.y = 3
        pointLight.position.z = 4
        scene.add(pointLight)

5. MeshLambertMaterial :
    - MeshLambertMaterial will react to light
        const material = new THREE.MeshLambertMaterial()
    - MeshLambertMaterial have new properties related to lights bur we will see those later with a more adequaet material 
        It's performant but we can see strange patterns on the gepmetry 

6. MeshPhongMaterial :
    -MeshPhongMaterial is similar to MeshLambertMaterial, but that strange patterns are less visible and you can also see the light reflection
        const material = new THREE.MeshPhongMaterial()
    - We can control the ligth reflection with shininess and the color of this reflection with specular
        material.shininess = 100
        material.specular = new THREE.Color(0xffff)

7. MeshToonMaterial :
    - MeshToonMaterial is similar to MeshLambertMaterial but with a cartoonish
        const material = new THREE.MeshToonMaterial()
    - To add more steps to the coloration, you can use the gradientMap property and use the gradientTexture
        material.gradientMap = gradientTexture
    - We see a gradient insted of a clear seperation because te gradient is small and the magFilter tries to fix it with the mipmapping
      Set the minFilter and magFilter to THREE.NearestFilter 
      WE can also deactivate the mipmapping with gradientTexture.generateMipmaps = false
        gradientTexture.minFilter = THREE.NearestFilter
        gradientTexture.magFilter = THREE.NearestFilter
        gradientTexture.generateMipmaps = false
    
8. MeshStandardMaterial :
    - MeshStandardMaterial uses physically based rendering principles(PBR) like MeshLambertMaterial and MeshPhongMaterial, it supports lights but with a more realiatic algorithm and better parameters like roughness and metalness.
        const Material = new THREE.MeshStandardMaterial()
    - We can change the roughness and metalness
        material.metalness = 0.45
        material.roughness = 0.65
    
- Add a debug UI :
    - Now it is good time to add a debug UI
    - In the terminal, On the project folder, run npm install --save dat.gui
    - On top of the code, import dat.gui
        import * as dat from 'dat.gui'
    - instantiate dat.GUI()
        const gui = new dat.GUI()
    - Add the tweaks (but add after creating a material otherwise JS errors)
        gui.add(material,'metalness').min(0).max(1).step(0.0001)//here step is precision
        gui.add(material,'roughness').min(0).max(1).step(0.0001)
    - map allows you to apply a texture 
        material.map = doorColorTexture
    - aoMap('ambient occlusion map') will add shadows where the texture is dark 
        We must add a second set of UV named uv2.
    - In our case, it's the same co-ordinate as the default UV so we are going to re-use it
        sphere.geometry.setAttribute('uv2', new THREE.BufferAttribute(sphere.geometry.attributes.uv.array, 2))
        plane.geometry.setAttribute('uv2', new THREE.BufferAttribute(plane.geometry.attributes.uv.array, 2))
        torus.geometry.setAttribute('uv2', new THREE.BufferAttribute(torus.geometry.attributes.uv.array, 2))
    - Add the aoMap with the doorAmbientOcclusionTexture texture and control the internsity with aoMapIntensity
        material.aoMapIntensity = 1
    
    - displacementMap will move the vertices to create relief
        Material.displacementMap = doorHeightTexture 
    - It should look terrible because it lacks vertices and the displacement is way to strong
        material.displacementScale = 0.5

        new THREE.SphereBufferGeometry(0.5, 64, 64),

        new THREE.PlaneBufferGeometry(1, 1, 100, 100),

        new THREE.TorusBufferGeometry(0.3, 0.2, 64, 128),

    - insted of specifying uniform metalness and roughness for the whole geometry, we can use metalnessMap and roughnessMap
        material.metalnessMap = doorMetalnessTexture
        material.roughnessMap = doorRoughnessTexture

    - The reflection looks weird because the metalness and roughness properties still affect each map respectively
      comment metalness and roughness or we can use their original values
        material.metalness = 0 
        material,roughness = 1

    - normalMap will fake the normals oriention and addd details on the surface regardless of the sundivision
        material.normalMap = doorNormalTexture
    - We can chnage the normal internsity with the normalScale property(Vector2)
        material.normalScale.set(0.5, 0.5 )
    - We can control the alpha using alphaMap property (Don't forget transparent = true)
        material.transparent = true
        material.aplhaMap = doorAlphaTexture
    
9. MeshPhysicalMaterial :   
    - MeshPhysicalMaterial is the same as MeshStandardMaterial but with support of a clear coat effect 

10. PointsMaterial :
    We can use PointsMaterial with Particles

11. ShaderMaterial and RawShadersMaterial can both be used to create your own materials
 
Environment Map :
    - The environment map is an image of what's surrounding the scence.
       It can be used for reflection or refraction but also for general lighting
       Environment maps are supported by multiple materials but we are going to use MeshStandardMaterial 
    - set a MeshStandardMaterial
        const material = new THREE.MeshStandardMaterial()
        material.metalness = 0.7
        material.roughness = 0.2
    - Thee.js only supports cube environment maps , we can find multiple environment maps in the /static/textures/environmentMap folder
    - To load a cube texture, we must use the CubeTextureLoader insted of TextureLoader
    - instantiate the CubeTextureLoader before instantiating the Material and call its load(..) method but use an array of paths
        const cubeTextureLoader = new THREE.CubeTextureLoader()

        const environmentMapTexture = cubeTextureLoader.load([
        '/textures/environmentMaps/0/px.jpg',
        '/textures/environmentMaps/0/nx.jpg',
        '/textures/environmentMaps/0/py.jpg',
        '/textures/environmentMaps/0/ny.jpg',
        '/textures/environmentMaps/0/pz.jpg',
        '/textures/environmentMaps/0/nz.jpg'
        ])

    - Use the environmentMapTexture in the envMap property of the material
        material.envMap = environmentMapTexture 

    - You can tweak the metalness and roughness for different results and test other environment maps from the /static/textures/environmentMap/ folder


